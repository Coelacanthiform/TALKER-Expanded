---@diagnostic disable: undefined-global
package.path = package.path .. ";./bin/lua/?.lua;"


local trigger = require("interface.trigger")
local AI_request = require("infra.AI.requests")
local game = require("infra.game_adapter")
local log = require("framework.logger")

-- Import game interface modules
local queries = talker_game_queries
---------------------------------------------------------------------------------------------
-- CONDITIONS
--------------------------------------------------------------------------------------------
local last_idle_conversation_time_ms = 0
local idle_conversation_time_cooldown_ms = 12 * 60 * 1000 -- 12 minutes

local function cooldown_ready()
    return queries.get_game_time_ms() - last_idle_conversation_time_ms > idle_conversation_time_cooldown_ms
end

-- Fisher-Yates shuffle to randomize the order of candidates
local function shuffle(tbl)
    for i = #tbl, 2, -1 do
        local j = math.random(i)
        tbl[i], tbl[j] = tbl[j], tbl[i]
    end
end

-- Checks if any NPC near the player has spoken within a given threshold.
-- This is used to determine if there is a "moment of silence" suitable for an idle conversation.
local function has_anyone_spoken_recently()
    local RECENT_SPEECH_THRESHOLD_MS = 3 * 60 * 1000 -- 3 minutes

    local nearby_characters = game.get_characters_near_player()
    if not nearby_characters or #nearby_characters == 0 then
        return false -- No characters nearby, so nobody could have spoken.
    end

    local current_game_time = queries.get_game_time_ms()

    for _, character in ipairs(nearby_characters) do
        local last_spoke_time = AI_request.get_last_spoke_time(character.game_id)
        if last_spoke_time then
            if current_game_time - last_spoke_time < RECENT_SPEECH_THRESHOLD_MS then
                -- Found someone who spoke within the last 3 minutes.
                return true
            end
        end
    end

    -- If we get here, it means no one nearby has spoken recently.
    return false
end

---------------------------------------------------------------------------------------------
-- IDLE CONVERSATION
--------------------------------------------------------------------------------------------
function on_every_10_seconds()
    -- If the player is in combat or sleeping, reset the idle conversation cooldown and abort.
    -- This prevents an idle conversation from starting immediately after combat ends, immediately after waking up, or while the player is sleeping.
    -- Safety check for db.actor
    if not db.actor then return end

    local is_player_in_combat = #queries.get_enemies_fighting_player() ~= 0
    if is_player_in_combat or db.actor:has_info("actor_is_sleeping") then
        last_idle_conversation_time_ms = queries.get_game_time_ms()
        return
    end
 
    -- Check for a moment of silence suitable for idle conversation
    if has_anyone_spoken_recently() then
        log.debug("Aborting idle chatter check, someone has spoken recently.")
        return
    end
 
   if not cooldown_ready() then return end

    --- create event
    local all_candidates = game.get_characters_near_player()
    if not all_candidates or #all_candidates == 0 then return end

    -- Filter out invalid candidates (player, those in combat)
    local valid_candidates = {}
    for _, npc in ipairs(all_candidates) do
        local npc_obj = queries.get_obj_by_id(npc.game_id)
        if npc_obj and not queries.is_player(npc_obj) and not queries.is_in_combat(npc_obj) then
            table.insert(valid_candidates, npc_obj)
        end
    end

    -- If no valid candidates are left, do nothing.
    if #valid_candidates == 0 then return end

    -- Shuffle candidates to try them in a random order.
    shuffle(valid_candidates)

    local conversation_triggered = false
    for _, npc_obj in ipairs(valid_candidates) do

        local speaker_name = queries.get_name(npc_obj)
        local instruction = string.format("%s begins an idle conversation to pass the time. The next line of dialogue must be spoken by %s.", speaker_name, speaker_name)
        local speaker_character = game.create_character(npc_obj)
        -- Create game event using trigger.talker_character_instructions, which generates a prompt using only "%s begins an idle conversation to pass the time" as context
        local success = trigger.talker_character_instructions(instruction, speaker_character, false, { idle_only = true })

        if success then
            log.debug("TALKER: Idle chatter triggered for " .. speaker_name)
            conversation_triggered = true
            break -- Exit the loop on the first success
        end

    end

    -- An attempt to start a conversation was made. Reset the main cooldown to prevent spamming.
    -- This happens whether we succeeded or failed after trying all candidates.
    last_idle_conversation_time_ms = queries.get_game_time_ms()
end

--------------------------------------------------------------------------------------------
-- Set up
--------------------------------------------------------------------------------------------

local function safe_on_every_10_seconds()
    local status, err = pcall(function()
        on_every_10_seconds()
    end)
    if not status then
        log.error("Error in safe_on_every_10_seconds: " .. err)
    end
end

-- keep track of a timer and only do a real check every 10 seconds
local last_check_time_ms = 0
local CHECK_INTERVAL_MS = 10 * 1000
local function on_every_ms()
    if queries.get_game_time_ms() - last_check_time_ms < CHECK_INTERVAL_MS then return end
    last_check_time_ms = queries.get_game_time_ms()
    safe_on_every_10_seconds()
end

function on_game_start()
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("actor_on_update", on_every_ms)
end

function save_state(data)
    data.talker_idle_last_check_time_ms = last_check_time_ms
end

function load_state(data)
    last_check_time_ms = data.talker_idle_last_check_time_ms or 0
    -- Reset the idle conversation cooldown to the current game time upon loading.
    -- This prevents an idle conversation from firing immediately after loading a save.
    last_idle_conversation_time_ms = queries.get_game_time_ms()
end

function is_loaded()
    return true
end
