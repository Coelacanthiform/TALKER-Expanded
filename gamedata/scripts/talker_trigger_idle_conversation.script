---@diagnostic disable: undefined-global
package.path = package.path .. ";./bin/lua/?.lua;"

local interface = require("interface.interface")
local AI_request = require("infra.AI.requests")
local game = require("infra.game_adapter")
local log = require('framework.logger')

-- Import game interface modules
local queries = talker_game_queries
---------------------------------------------------------------------------------------------
-- CONDITIONS
--------------------------------------------------------------------------------------------
local last_idle_conversation_time_ms = 0
local idle_conversation_time_cooldown_ms = 4 * 60 * 1000 -- 4 minutes

local function cooldown_ready()
    return queries.get_game_time_ms() - last_idle_conversation_time_ms > idle_conversation_time_cooldown_ms
end

-- Fisher-Yates shuffle to randomize the order of candidates
local function shuffle(tbl)
    for i = #tbl, 2, -1 do
        local j = math.random(i)
        tbl[i], tbl[j] = tbl[j], tbl[i]
    end
end
---------------------------------------------------------------------------------------------
-- IDLE CONVERSATION
--------------------------------------------------------------------------------------------
function on_every_10_seconds()
    -- If the player is in combat, reset the idle conversation cooldown and abort.
    -- This prevents an idle conversation from starting immediately after combat ends.
    local is_player_in_combat = #queries.get_enemies_fighting_player() ~= 0
    if is_player_in_combat then
        last_idle_conversation_time_ms = queries.get_game_time_ms()
        return
    end
 
     -- New check: If anyone nearby has spoken recently, it's not a moment of silence.
    if interface.has_anyone_spoken_recently() then
        log.debug("Aborting idle chatter check, someone has spoken recently.")
        return
    end
 
   if not cooldown_ready() then return end

    --- create event
    local all_candidates = game.get_characters_near_player()
    if not all_candidates or #all_candidates == 0 then return end

    -- Filter out invalid candidates (player, those in combat)
    local valid_candidates = {}
    for _, npc in ipairs(all_candidates) do
        -- The 'npc' is a custom Character table. We need the raw game object for queries.
        local npc_obj = queries.get_obj_by_id(npc.game_id)
        -- Check is_in_combat FIRST, as it safely handles dead/nil NPCs.
        -- is_player also includes a nil check.
        if npc_obj and not queries.is_player(npc_obj) and not queries.is_in_combat(npc_obj) then
            table.insert(valid_candidates, npc_obj)
        end
    end

    -- If no valid candidates are left, do nothing.
    if #valid_candidates == 0 then return end

    -- Shuffle candidates to try them in a random order.
    shuffle(valid_candidates)

    local conversation_triggered = false
    for _, npc_obj in ipairs(valid_candidates) do
        -- Check the AI's internal cooldown for this specific NPC before trying to make them speak.
        local remaining_cooldown = AI_request.get_remaining_cooldown(npc_obj:id(), queries.get_game_time_ms())
        if remaining_cooldown > 0 then
            log.debug("Skipping %s for idle chatter, still on individual cooldown for %s ms", queries.get_name(npc_obj), remaining_cooldown)
            goto continue -- Skip to the next NPC in the loop
        end

        local speaker_name = queries.get_name(npc_obj)
        local instruction = string.format("%s begins an idle conversation to pass the time. The next line of dialogue must be spoken by %s.", speaker_name, speaker_name)
        
        -- Create a Character object, as expected by the interface function.
        local speaker_character = game.create_character(npc_obj)
        local success = interface.register_character_instructions(instruction, speaker_character, false, { idle_only = true })

        if success then
            log.debug("TALKER: Idle chatter triggered for " .. speaker_name)
            conversation_triggered = true
            break -- Exit the loop on the first success
        end

        ::continue:: -- Label for the goto statement
    end

    -- An attempt to start a conversation was made. Reset the main cooldown to prevent spamming.
    -- This happens whether we succeeded or failed after trying all candidates.
    last_idle_conversation_time_ms = queries.get_game_time_ms()
end

--------------------------------------------------------------------------------------------
-- Set up
--------------------------------------------------------------------------------------------

local function safe_on_every_10_seconds()
    local status, err = pcall(function()
        on_every_10_seconds()
    end)
    if not status then
        log.error("Error in safe_on_every_10_seconds: " .. err)
    end
end

-- keep track of a timer and only do a real check every 10 seconds
local last_check_time_ms = 0
local CHECK_INTERVAL_MS = 10 * 1000
local function on_every_ms()
    if queries.get_game_time_ms() - last_check_time_ms < CHECK_INTERVAL_MS then return end
    last_check_time_ms = queries.get_game_time_ms()
    safe_on_every_10_seconds()
end

function on_game_start()
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("actor_on_update", on_every_ms)
end

function save_state(data)
    data.talker_idle_last_check_time_ms = last_check_time_ms
end

function load_state(data)
    last_check_time_ms = data.talker_idle_last_check_time_ms or 0
    -- Reset the idle conversation cooldown to the current game time upon loading.
    -- This prevents an idle conversation from firing immediately after loading a save.
    last_idle_conversation_time_ms = queries.get_game_time_ms()
end

function is_loaded()
    return true
end
